Pregunta 4.1: Se utilizan n=100000000 rectángulos, que a su vez se dividen en dos para calcular la imagen del punto medio del rectángulo, pero se calcula la suma de las áreas de esos 100000000.

Pregunta 4.2: Que la v4 utiliza una variable privada para ir guardando los resultados de las sumas y luego guarda el resultado final en su parte del array sum, mientras que la v1, aunque solo a su parte del array, accede a la misma variable sum desde todos los hilos en cada iterración.

Ejercicio 4.3: En el resultado no se obtiene ninguna diferencia, sin embargo, el rendimiento de la v4 es mejor que el de la v1 en aproximadamente un 70%. Esto se debe a que al guardar la variable sum en la cache, varias posiciones del array se guardan en el mismo bloque, entonces, como la variable sum es compartida en la v1, si varios hilos acceden a la vez a partes de larray que están en el mismo bloque de la caché, habrá un retardo por concurrencia ya que solo una puede acceder a los datos a la vez para evitar inconsistencia en los datos, lo que retarda la ejecución del programa.

Ejercicio 4.4: El resultado en ambos es el mismo he igual al resto. En cuanto al rendimiento de la v2, es muy similar al de la v1, ya que aunque comparta la variable sum donde se guarda la direccíón de memoria del array, este sigue siendo compartido y no soluciona el problema de la v1. La v4 sin embargo, al ver el tamaño de cada bloque de la caché, y asignar un bloque a cada hilo, aunque consuma más memoria, consigue solucionar el problema de concurrencia y conseguir un rendimiento similar al de la v4.

Ejercicio 4.5: Se aprecia que a medida que aumenta el número se va mejorando el rendimiento, hasta llegar a 8, a partir del cual se estabiliza y tarda aproximadamente lo mismo. Esto tiene sentido pues una vez se llega a 8, aunque dejes más espacio entre las posiciones del array que utiliza cada hilo, solo habrá una a la que se acceda en cada bloque de la caché, eliminando así la concurrencia para cualquier valor mayor o igual a 8.

Ejercicio 5.1: Al usar la directiva critical, se establece que solo un hilo puede ejecutar el bloque de código asociado (en este caso, la línea) al mismo tiempo. Esto permite sumar directamente el valor de las sumas que realiza cada hilo al valor de pi provisional cunado estos terminjan la ejecución en lugar de hacerlo sobre una variable privada falsa y luego sumárselo después. Sin embargo, debido a que la i utilizada en el bucle for y a que la variable pi no está inicializada, el resultado de pi_par5 es incorrecto, y tiene un tiempo de ejecución considerablemente mayor al esperado. Por ello, para poder comparar ambos programas correctamente, hemos corregido estos errores y hemos comprobado que los tiempos de ejecucíon son muy similares. Esto tiene sentido ya que aunque en pi_par4 también hay concurrencia cuando los espacios del array están en el mismo bloque, habrá menos que en pi_par5, en el que simepre hay concurrencia; aunque por otro lado, en pi_par5 se ahorra el bucle que suma las sumas parciales, por lo que le tiempo de ejecución tendrá que ser similar.

Ejercicio 5.2: En pi_par6, en cada hilo se calculan todas las sumas parciales que se realizan para calcular pi, aunque a su vez en hilos distintos, sin embargo se hacen las mismas sumas tantas veces como núcleos tenga la máquina, lo que no es muy eficiente. En cambio en pi_par7, lo que se hace con la directiva reduction, es hacer que las variables sum sean privadas en cada hilo, y al terminar las suma, por lo que elimina la concurrencia y evita el bucle que las suma todas, lo que aunmenta considerablemente el rendimiento respecto a pi_par6.


*Nota: el script ejercicio4-7.sh realiza las ejecuciones necesarias para resolver el ejerciico 4.5, volcando los datos obtenidos en el fichero tiempos_4-5.dat.